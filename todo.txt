demo:
    all stages of the hough transform
    show interactive mode and stream mode
    live fisheye calibration
    v4l2/ffmpeg camera input

o server: Use INADDR_ANY.
    http://stackoverflow.com/questions/4046616/sockets-how-to-find-out-what-port-and-address-im-assigned
    http://stackoverflow.com/questions/212528/get-the-ip-address-of-the-machine

o browser/server: log data

o browser: camera
    click on element to orbit around it

o server: mapping, hovering, labels and pausing
    - Problem: In stream-mode, the server cannot necessarily
    reproduce the visualization, because the data might be updated.
    Hence, if the browser has paused to inspect, and would like
    to hover over an element to see its label (and maybe do some
    conditional drawing), the server cannot reproduce the correct
    label.
    - Solution: Server _stores_ labels for each drawn element, but
    only sends the ones that are necessary. Will require tremendous
    amounts of storage though!! 100k point x 64 byte = 6 mb
        for i=1..n
            vdb_label("Votes: %d\nr: %.2f\nt: %.2f", ...)
            vdb_color1f(votes/peak);
            vdb_point(t, r);
    - And what about conditional draw calls?
        if (vdbMap(t,r)) { draw many points... } like in hough transform
        Storing the conditional draw calls for each possible outcome
        would require _way_ much memory.

    ALTERNATIVELY: At an additional burder of the programmer

    + Can do conditional drawing
    + Can pause _into_ interactive mode
        (although I suppose you could always do that, but at the risk
        of the programmer that you might change values that should not
        be changed at runtime!!)
    - Less storage requirements, unless the copied data is gigantic

    if (vdb_begin()) <- Can check if the browser has currently paused execution
    {
        if (vdb_shouldupdate()) <- true if not paused
        {
            // copy hough table into local variable
        }

        vdb_end();
    }

    ALTERNATIVELY: Limit inspection like that to interactive-mode???

o server/browser: Filter draw-calls by color!!
    Can solve the visualize-hough-support-points problem.
    Each line and its support points are labelled with the same color.
    Then, in the browser, we can filter by one color at a time.
    That won't really work if a point can support multiple lines??

o What about views? Precompute on server?
    vdb_xview(left, right) sets viewport in window
    vdb_xrange(left, right) maps [left,right] to viewport edges

    vdb_xview(-1,+1);
    vdb_yview(-1,+1);
    vdb_xrange(t_min, t_max);
    vdb_yrange(r_min, r_max);
    vdb_point(t, r);

    How does this interact with user-controlled cameras?
    And vdb_map??

o Overlay views in browser?

o browser: color linking
    In browser:
        Can link 'color' to both
        -> Indexed palette (qualitative, sequential, gray, ...)
        (see matlabcolors.jpg)
        -> Scale of geometry
        Either or both

o misc: Labels
    A string of bytes is sent along with the command buffer
    describing where (x,y) and what (%s).
        if (vdb_map(x, y))
        {
            vdb_label(x, y, "%s", ...);
        }

        -->
        if (x,y is closest to latest cursor position)
        {
            cmdbuf.label_x = x;
            cmdbuf.label_y = y;
            cmdbuf.label_s = s;
        }
    Cursor position is received from browser per frame?

o server: WebGL + offscreen canvas for text
    + Can send color and size per line and point efficiently!
    + Don't need to implement line clipping!
    http://murfy.de/read/webgl-text-rendering
    https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API
    https://webglfundamentals.org/
    https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html
    http://twgljs.org/

o server: Batching and draw commands

o server: msg queue, poll.

o server: send list of possible views and let browser filter
o server: hton and ntoh
o server: Receive large messages (accumulate, until FIN)

o server: vdb_text
o server: vdb_lines, vdb_points modes
o server: vdb_color (non-indexed)
o server/browser: interactive
    - keypresses, keyholds, keyups

o browser: user-defined interface sidebar
o browser: SVG icons (https://material.io/icons/#ic_mode_comment)

o brower: Dynamic quality balance with performance
    - Toggle nice points or square points
    - Line subdivision quality (avoid subdivision for pinhole projection!)

o browser: idle anim
    https://projects.lukehaas.me/css-loaders/
    http://imgur.com/gallery/s7N6N

o browser: dynamic viewport and canvas size

o server:
    send_thread should be able to check if the work-buffer is ready to be sent
    (cause it might not have been signalled to be sent because send_thread was
    busy, and it might take a long time before it can be signalled again).

o server: Static textures
    Not updated every loop iteration

o brower: Logging console
o browser: Hide or show axes
o browser: Set canvas width height programmatically?
o browser: Pausing to inspect in stream mode
o browser: Scroll back frames in history
o browser: Equidistant projection
o browser: Pinhole projection with Brown-Conrady distortion
o browser: Dynamic line rendering (binary search, curvature)

o server: Request look-up in Hough table?
o server: namespaces
    namespace socket
    {
        #include <winsock.h>
    }
    #pragma comment(lib, "wsock32.lib")

    int main()
    {
        socket::send();

        socket::Sleep(1000);
    }
