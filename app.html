<html>
<head>
<title>vdebug</title>

<!-- STYLE BEGIN -->
<style>
body {
    font-family: roboto, sans-serif;
    font-size: 13px;
    background: #f1f1f1;
    margin: 0;
}

#canvas {
    border-radius: 4px;
    background: #fff;
    box-shadow: 0px 2px 2px #A7A7A7;
    display: block;
    margin-left: auto;
    margin-right: auto;
    margin-top: 12px;
    margin-bottom: 12px;
    width: 640px;
    height: 320px;
}

#container {
    width: 640px;
    height: 480px;
    display: block;
    margin: auto;
}

#user_config { float: right; }
#status { display: inline; color: #888; }
#fps { display: inline; color: #888; }

.input_thing select { width: 100px; }
input { width: 100px; vertical-align: middle; padding: 0; margin: 0; }
.input_thing { border-radius: 2px; box-shadow: 0px 2px 2px #a7a7a7; background:#fff; width: 280px; padding: 6px; margin-bottom: 8px; }

a { background: #bb5544; vertical-align: middle; padding: 2px 4px 2px 4px; border-radius: 2px; color: #fff; text-decoration: none; }
a:hover { background: #cc6655;}
a:active { background: #dd7766; }
</style>
<!-- STYLE END -->

<!-- SHADERS BEGIN -->
<script id="shader_vs" type="notjs">
    attribute vec4 coord;
    attribute vec4 color;
    attribute vec2 texel;
    varying vec4 v_color;
    varying vec2 v_texel;
    void main()
    {
        v_color = color;
        v_texel = texel;
        gl_Position = coord;
    }
</script>
<script id="shader_fs" type="notjs">
    precision mediump float;
    varying vec4 v_color;
    varying vec2 v_texel;
    uniform sampler2D channel0;
    void main()
    {
        gl_FragColor = v_color*texture2D(channel0, v_texel);
    }
</script>
<!-- SHADERS END -->

<!-- SCRIPT BEGIN -->
<script>
var ws = null;
var has_connection = false;
var cmd_data = null;

var cvs = null;
var gl = null;

var program = null;
var loc_coord = null;
var loc_color = null;
var loc_texel = null;
var loc_chan0 = null;

var vbo_user_coord = null;
var vbo_user_color = null;
var vbo_user_texel = null;
var vbo_quad_coord = null;
var vbo_quad_color = null;
var vbo_quad_texel = null;

var tex_white = null;
var tex_view0 = null;

var palette_index = 0;

var tex_view0_active = false;
var tex_view0_width = 0;
var tex_view0_height = 0;

// User interface
var line_width = 4.0;   // in pixels
var point_radius = 4.0; // in pixels
var nice_points = false;
var connection_address = "localhost:8000";

// Variable modifiers
var mod1f_registered = false;
var mod1f_lobits = null;
var mod1f_hibits = null;
var mod1f_min_value = 0.0;
var mod1f_max_value = 1.0;
var mod1f_value = 0.0;

function rgbToHex(rf, gf, bf)
{
    var r = Math.floor(rf*255.0);
    var g = Math.floor(gf*255.0);
    var b = Math.floor(bf*255.0);
    return (r << 24) | (g << 16) | (b << 8) | 0xFF;
}

var palette_index = 0;
function colorPalette(color)
{
    var palettes = [
        // Bright
        [0x66c1a3ff, 0xfc8c60ff, 0x89a0d1ff, 0xe889c4ff, 0xa3db49ff, 0xffd830ff, 0xe2c493ff, 0xb2b2b2ff],
        // Spectral
        [0x9E0142FF,0xD53E4FFF,0xF46D43FF,0xFDAE61FF,0xFEE08BFF,0xFFFFBFFF,0xE6F598FF,0xABDDA4FF,0x66C2A5FF,0x3288BDFF,0x5E4FA2FF],
        // BrownBlueGreen
        [0x003C30FF,0x01665EFF,0x35978FFF,0x80CDC1FF,0xC7EAE5FF,0xF5F5F5FF,0xF6E8C3FF,0xDFC27DFF,0xBF812DFF,0x8C510AFF,0x543005FF],
        // Blue
        [0x08306BFF,0x08519CFF,0x2171B5FF,0x4292C6FF,0x6BAED6FF,0x9ECAE1FF,0xC6DBEFFF,0xDEEBF7FF,0xF7FBFFFF],
        // GreenBlue
        [0x084081FF,0x0868ACFF,0x2B8CBEFF,0x4EB3D3FF,0x7BCCC4FF,0xA8DDB5FF,0xCCEBC5FF,0xE0F3DBFF,0xF7FCF0FF],
        // Set 1
        [0xE41A1CFF,0x377EB8FF,0x4DAF4AFF,0x984EA3FF,0xFF7F00FF,0xFFFF33FF,0xA65628FF,0xF781BFFF]
    ];
    return palettes[palette_index][color % (palettes[palette_index].length)];
}

var alpha_value = 120;
function alphaPalette(alpha)
{
    if (alpha == 0) return 255;
    if (alpha == 1) return alpha_value;
}

function generateTriangles(commands)
{
    tex_view0_active = false;

    var coords = [];
    var colors = [];
    var count = 0;

    var little_endian = true;
    var view = new DataView(commands);
    var offset = 0;

    while (offset < view.byteLength)
    {
        var mode = view.getUint8(offset, little_endian); offset += 1;
        var style = view.getUint8(offset, little_endian); offset += 1;

        var style_color_index = style & 0x7F;
        var style_alpha_index = (style >> 7) & 0x01;
        var color = colorPalette(style_color_index);
        var color_r = (color >> 24) & 0xFF;
        var color_g = (color >> 16) & 0xFF;
        var color_b = (color >>  8) & 0xFF;
        var color_a = alphaPalette(style_alpha_index) & 0xFF;

        if (mode == 1) // point2
        {
            var x = view.getFloat32(offset, little_endian); offset += 4;
            var y = view.getFloat32(offset, little_endian); offset += 4;

            var rx = point_radius/(cvs.width/2.0);
            var ry = point_radius/(cvs.height/2.0);

            if (nice_points)
            {
                var n = 32;
                for (var i = 0; i < n; i++)
                {
                    var t1 = 2.0*3.1415926*i/n;
                    var t2 = 2.0*3.1415926*(i+1)/n;
                    var x1 = x;
                    var y1 = y;
                    var x2 = x1 + rx*Math.cos(t1);
                    var y2 = y1 + ry*Math.sin(t1);
                    var x3 = x1 + rx*Math.cos(t2);
                    var y3 = y1 + ry*Math.sin(t2);
                    coords.push(x1,y1, x2,y2, x3,y3);
                    colors.push(color_r,color_g,color_b,color_a,
                                color_r,color_g,color_b,color_a,
                                color_r,color_g,color_b,color_a);
                    count += 3;
                }
            }
            else
            {
                var x1 = x-rx;
                var x2 = x+rx;
                var y1 = y-ry;
                var y2 = y+ry;
                coords.push(x1,y1, x2,y1, x2,y2, x2,y2, x1,y2, x1,y1);
                colors.push(color_r,color_g,color_b,color_a,
                            color_r,color_g,color_b,color_a,
                            color_r,color_g,color_b,color_a,
                            color_r,color_g,color_b,color_a,
                            color_r,color_g,color_b,color_a,
                            color_r,color_g,color_b,color_a);
                count += 6;
            }
        }
        else if (mode == 2) // point3
        {
            var x_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var y_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var z_ndc = view.getFloat32(offset, little_endian); offset += 4;
        }
        else if (mode == 3) // line2
        {
            var x1 = view.getFloat32(offset, little_endian); offset += 4;
            var y1 = view.getFloat32(offset, little_endian); offset += 4;
            var x2 = view.getFloat32(offset, little_endian); offset += 4;
            var y2 = view.getFloat32(offset, little_endian); offset += 4;

            var ln = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
            var nx = -(y2-y1) / ln;
            var ny = (x2-x1) / ln;

            var rx = (line_width/2.0)/(cvs.width/2.0);
            var ry = (line_width/2.0)/(cvs.height/2.0);
            var x11 = x1 - nx*rx;
            var y11 = y1 - ny*ry;
            var x21 = x2 - nx*rx;
            var y21 = y2 - ny*ry;
            var x12 = x1 + nx*rx;
            var y12 = y1 + ny*ry;
            var x22 = x2 + nx*rx;
            var y22 = y2 + ny*ry;

            coords.push(x11,y11, x21,y21, x22,y22, x22,y22, x12,y12, x11,y11);
            colors.push(color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a);
            count += 6;
        }
        else if (mode == 4) // line3
        {
            var x1_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var y1_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var z1_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var x2_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var y2_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var z2_ndc = view.getFloat32(offset, little_endian); offset += 4;
        }
        else if (mode == 5) // fillRect
        {
            var x1 = view.getFloat32(offset, little_endian); offset += 4;
            var y1 = view.getFloat32(offset, little_endian); offset += 4;
            var x2 = view.getFloat32(offset, little_endian); offset += 4;
            var y2 = view.getFloat32(offset, little_endian); offset += 4;
            coords.push(x1,y1, x2,y1, x2,y2, x2,y2, x1,y2, x1,y1);
            colors.push(color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a);
            count += 6;
        }
        else if (mode == 6) // circle
        {
            var x = view.getFloat32(offset, little_endian); offset += 4;
            var y = view.getFloat32(offset, little_endian); offset += 4;
            var r = view.getFloat32(offset, little_endian); offset += 4;

            var n = 32;
            for (var i = 0; i < n; i++)
            {
                var t1 = 2.0*3.1415926*i/n;
                var t2 = 2.0*3.1415926*(i+1)/n;
                var x1 = x;
                var y1 = y;
                var x2 = x1 + r*Math.cos(t1);
                var y2 = y1 + r*Math.sin(t1);
                var x3 = x1 + r*Math.cos(t2);
                var y3 = y1 + r*Math.sin(t2);
                coords.push(x1,y1, x2,y2, x3,y3);
                colors.push(color_r,color_g,color_b,color_a,
                            color_r,color_g,color_b,color_a,
                            color_r,color_g,color_b,color_a);
                count += 3;
            }
        }
        else if (mode == 7) // image_rgb8
        {
            var width = view.getUint32(offset, little_endian); offset += 4;
            var height = view.getUint32(offset, little_endian); offset += 4;
            var size = width*height*3;

            var data = new Uint8Array(commands, offset, size);
            offset += size;

            if (tex_view0_width != width || tex_view0_height != height)
            // if (1) // @ texture upload optimization
            {
                tex_view0_width = width;
                tex_view0_height = height;
                gl.bindTexture(gl.TEXTURE_2D, tex_view0);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_BYTE, data);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            else
            {
                gl.bindTexture(gl.TEXTURE_2D, tex_view0);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGB, gl.UNSIGNED_BYTE, data);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            tex_view0_active = true;
            data = null;
        }
        else if (mode == 254) // slider float
        {
            if (!mod1f_registered)
            {
                mod1f_registered = true;
                mod1f_lobits = view.getUint32(offset, little_endian); offset += 4;
                mod1f_hibits = view.getUint32(offset, little_endian); offset += 4;
                mod1f_value = view.getFloat32(offset, little_endian); offset += 4;
                mod1f_min_value = view.getFloat32(offset, little_endian); offset += 4;
                mod1f_max_value = view.getFloat32(offset, little_endian); offset += 4;
                document.getElementById("mod1f_range").min = mod1f_min_value;
                document.getElementById("mod1f_range").max = mod1f_max_value;
                document.getElementById("mod1f_range").value = mod1f_value;
                document.getElementById("mod1f_label_name").innerHTML = "x: ";
                document.getElementById("mod1f_label_value").innerHTML = mod1f_value.toPrecision(4);
            }
        }
        else if (mode == 255) // aspect
        {
            var w = view.getFloat32(offset, little_endian); offset += 4;
            var h = view.getFloat32(offset, little_endian); offset += 4;
            var new_w = cvs.clientHeight * w / h;

            var element = document.getElementById("canvas");
            element.style.width = new_w + "px";
        }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, vbo_user_coord);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coords), gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, vbo_user_color);
    gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(colors), gl.STATIC_DRAW);

    coords = null;
    colors = null;
    view = null;

    return count;
}

function createShader(gl, type, source)
{
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success)
        return shader;
    console.log(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
}

function createProgram(gl, vs, fs)
{
    var program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success)
        return program;
    console.log(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
}

function init()
{
    // Compile the ubershader
    var shader_vs_src = document.getElementById("shader_vs").text;
    var shader_fs_src = document.getElementById("shader_fs").text;
    var shader_vs = createShader(gl, gl.VERTEX_SHADER, shader_vs_src);
    var shader_fs = createShader(gl, gl.FRAGMENT_SHADER, shader_fs_src);
    program = createProgram(gl, shader_vs, shader_fs);

    // Get attribute locations
    loc_coord = gl.getAttribLocation(program, "coord");
    loc_color = gl.getAttribLocation(program, "color");
    loc_texel = gl.getAttribLocation(program, "texel");
    loc_chan0 = gl.getUniformLocation(program, "chan0");

    // These vertex buffers are updated in generateTriangles
    vbo_user_coord = gl.createBuffer();
    vbo_user_color = gl.createBuffer();
    vbo_user_texel = gl.createBuffer();

    // These vertex buffers are used to draw background textures
    vbo_quad_coord = gl.createBuffer();
    vbo_quad_color = gl.createBuffer();
    vbo_quad_texel = gl.createBuffer();
    {
        var coords = [ -1,-1, +1,-1, +1,+1, +1,+1, -1,+1, -1,-1 ];
        var texels = [ 0,0, 1,0, 1,1, 1,1, 0,1, 0,0 ];
        var colors = [ 255,255,255,255, 255,255,255,255, 255,255,255,255, 255,255,255,255, 255,255,255,255, 255,255,255,255 ];
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_quad_coord); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coords), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_quad_color); gl.bufferData(gl.ARRAY_BUFFER, new   Uint8Array(colors), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_quad_texel); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texels), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }

    // This texture is for drawing non-textured geometry
    tex_white = gl.createTexture();
    {
        var data = new Uint8Array([255,255,255,255]);
        gl.bindTexture(gl.TEXTURE_2D, tex_white);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    // These textures can be assigned data by the user (from generateTriangles)
    tex_view0 = gl.createTexture();
    tex_view0_active = false;
}

function draw()
{
    // Update parameters from GUI
    line_width = parseFloat(document.getElementById("line_width").value);
    point_radius = parseFloat(document.getElementById("point_radius").value);
    alpha_value = parseFloat(document.getElementById("alpha_value").value);
    nice_points = document.getElementById("nice_points").checked;
    {
        palette_index = document.getElementById("color_palette").selectedIndex;
    }

    // Resize framebuffer resolution to match size of displayed window
    if (cvs.width  != cvs.clientWidth || cvs.height != cvs.clientHeight)
    {
        cvs.width  = cvs.clientWidth;
        cvs.height = cvs.clientHeight;
    }

    var num_elements = 0;
    if (cmd_data != null)
        num_elements = generateTriangles(cmd_data);

    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(program);

    // Draw background texture (if any)
    if (tex_view0_active)
    {
        gl.activeTexture(gl.TEXTURE0 + 0);
        gl.bindTexture(gl.TEXTURE_2D, tex_view0);
        gl.enableVertexAttribArray(loc_coord);
        gl.enableVertexAttribArray(loc_color);
        gl.enableVertexAttribArray(loc_texel);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_quad_coord);
        gl.vertexAttribPointer(loc_coord, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_quad_color);
        gl.vertexAttribPointer(loc_color, 4, gl.UNSIGNED_BYTE, true, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_quad_texel);
        gl.vertexAttribPointer(loc_texel, 2, gl.FLOAT, false, 0, 0);
        gl.uniform1i(loc_chan0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    // Draw user geometry
    if (num_elements > 0)
    {
        gl.activeTexture(gl.TEXTURE0 + 0);
        gl.bindTexture(gl.TEXTURE_2D, tex_white);
        gl.enableVertexAttribArray(loc_coord);
        gl.enableVertexAttribArray(loc_color);
        gl.disableVertexAttribArray(loc_texel);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_user_coord);
        gl.vertexAttribPointer(loc_coord, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_user_color);
        gl.vertexAttribPointer(loc_color, 4, gl.UNSIGNED_BYTE, true, 0, 0);
        gl.uniform1i(loc_chan0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, num_elements);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
}

var connect_called = false;

function connect()
{
    if (connect_called)
        return;

    connect_called = true;

    connection_address = document.getElementById("connection_address").value;
    document.getElementById("connection_address").hidden = true;
    document.getElementById("button_connect").hidden = true;
    document.getElementById("status").hidden = false;

    setInterval(function()
    {
        if (!ws)
        {
            document.getElementById("status").innerHTML = "Connecting to " + connection_address + "...";

            ws = new WebSocket("ws://" + connection_address);
            ws.binaryType = 'arraybuffer';

            ws.onopen = function()
            {
                document.getElementById("status").innerHTML = "Connected to " + connection_address;
                ws.send("Hello from browser!");
                has_connection = true;
            }

            ws.onclose = function()
            {
                mod1f_registered = false;
                tex_view0_active = false;
                cmd_data = null;
                ws = null;
                has_connection = false;
            }

            ws.onmessage = function(e)
            {
                stats_bps_sum += e.data.byteLength;
                if (stats_bps_dt > 1.0)
                {
                    stats_bps = stats_bps_sum / stats_bps_dt;
                    stats_bps_sum = 0.0;
                    stats_bps_dt = 0.0;
                }
                var mbps = (10.0*stats_bps/(1024.0*1024.0)).toPrecision(2);

                document.getElementById("status").innerHTML = "Connected to " + connection_address + " (" + mbps + " mbps)";
                cmd_data = e.data;
            }
        }
    }, 250);
}

var animation_frame_t_first = null;
var animation_frame_t_prev = null;
var stats_bps_sum = 0;
var stats_bps_dt = 0;
var stats_bps = 0;
function anim(t)
{
    var delta = 1.0/60.0;
    var elapsed = 0.0;
    if (t)
    {
        if (!animation_frame_t_first) animation_frame_t_first = t;
        if (!animation_frame_t_prev) animation_frame_t_prev = t;
        delta = (t - animation_frame_t_prev)/1000.0;
        elapsed = (t - animation_frame_t_first)/1000.0;
        animation_frame_t_prev = t;
    }

    var status = document.getElementById("status");
    if (has_connection)
    {
        stats_bps_dt += delta;
        draw();

        if (mod1f_registered)
        {
            ws.send("f '" + mod1f_lobits + "' '" + mod1f_hibits + "' " + mod1f_value);
        }
    }
    else
    {
        draw();
    }

    var p_fps = document.getElementById("fps");
    p_fps.innerText = "FPS: " + (1.0/delta).toPrecision(4);

    requestAnimationFrame(anim);
}

// function onKeyUp(e)
// {
//     if (event.keyCode == 13)
//         ws.send("c");
// }

function load()
{
    if (!("WebSocket" in window))
    {
        alert("Your browser does not support WebSockets! Sorry, good luck!");
        return;
    }

    cvs = document.getElementById("canvas");
    // gl = cvs.getContext("webgl");
    gl = cvs.getContext("webgl", {antialias: false});
    if (!gl)
    {
        console.log("Your browser does not support WebGL! Sorry, good luck!");
        return;
    }

    document.getElementById("connection_address").value = connection_address;
    document.getElementById("status").hidden = true;

    // connect();
    init();
    anim();
}

function mod1f_onchange(e)
{
    mod1f_value = parseFloat(e.value);
    document.getElementById("mod1f_label_value").innerHTML = mod1f_value.toPrecision(4);
}

function buttonConnect()
{
    connect();
}

function buttonContinue()
{
    ws.send("c");
}
</script>
<!-- SCRIPT END-->

<!-- HTML BEGIN -->
</head>
<body onload="load()">
    <div id="container">
        <canvas id="canvas"></canvas>

        <div id="user_config">
            <div class="input_thing">
                <a href="javascript:buttonContinue()">Continue</a>
                <p id="fps"></p>
            </div>

            <div class="input_thing">
                <label id="mod1f_label_name"></label>
                <input onchange="mod1f_onchange(this)" id="mod1f_range" min="0.0" max="1.0" step="0.01" value="0.5" type="range"/>
                <label id="mod1f_label_value"></label>
            </div>
        </div>

        <div id="config">
            <div class="input_thing">
                <input id="connection_address" type="text"/>
                <a id="button_connect" href="javascript:buttonConnect()">Connect</a>
                <p id="status"></p>
            </div>

            <div class="input_thing">
                <select id="color_palette">
                  <option value="0">Bright</option>
                  <option value="1">Spectral</option>
                  <option value="2">BrownBlueGreen</option>
                  <option value="3">Blue</option>
                  <option value="4">GreenBlue</option>
                  <option value="5">Set 1</option>
                </select>
                <label>Color palette</label>
            </div>

            <div class="input_thing">
                <input id="line_width" min="1.0" max="32.0" value="2.0" type="range"/>
                <label>Line size</label>
            </div>

            <div class="input_thing">
                <input id="point_radius" min="1.0" max="32.0" value="4.0" type="range"/>
                <label>Point size</label>
            </div>

            <div class="input_thing">
                <input id="alpha_value" min="0.0" max="255.0" value="120" type="range"/>
                <label>Alpha</label>
            </div>

            <div class="input_thing">
                <input id="nice_points" type="checkbox"/>
                <label>Nice points</label>
            </div>
        </div>
    </div>
</body>
</html>
<!-- HTML END -->
