<html>
<head>
<title>vdebug</title>

<!-- STYLE BEGIN -->
<style>
body {
    font-family: roboto, sans-serif;
    font-size: 13px;
    background: #f1f1f1;
    margin: 0;
}

#canvas {
    border-radius: 4px;
    background: #fff;
    box-shadow: 0px 2px 2px #A7A7A7;
    display: block;
    margin-left: auto;
    margin-right: auto;
    margin-top: 12px;
    margin-bottom: 12px;
    width: 600px;
    height: 300px;
}

#container {
    width: 640;
    height: 480;
    display: block;
    margin: auto;
}

#status, #fps {
    margin-top: 6px;
    text-align: center;
}

a { color: #fff; background: #bb5544; padding: 6px; box-shadow: 0px 2px 2px #a7a7a7; border-radius: 2px; text-decoration: none; }
a:hover { background: #cc6655;}
a:active { background: #dd7766; }
</style>
<!-- STYLE END -->

<!-- SHADERS BEGIN -->
<script id="shader_vs" type="notjs">
    attribute vec4 coord;
    attribute vec4 color;
    attribute vec2 texel;
    varying vec4 v_color;
    varying vec2 v_texel;
    void main()
    {
        v_color = color;
        v_texel = texel;
        gl_Position = coord;
    }
</script>
<script id="shader_fs" type="notjs">
    precision mediump float;
    varying vec4 v_color;
    varying vec2 v_texel;
    uniform sampler2D channel0;
    void main()
    {
        gl_FragColor = v_color*texture2D(channel0, v_texel);
    }
</script>
<!-- SHADERS END -->

<!-- SCRIPT BEGIN -->
<script>
var ws = null;
var has_connection = false;
var cmd_data = null;

var cvs = null;
var gl = null;

var program = null;
var loc_coord = null;
var loc_color = null;
var loc_texel = null;
var loc_chan0 = null;

var vbo_user_coord = null;
var vbo_user_color = null;
var vbo_user_texel = null;
var vbo_quad_coord = null;
var vbo_quad_color = null;
var vbo_quad_texel = null;

var tex_white = null;
var tex_view0 = null;

var palette_index = 0;

var tex_view0_active = false;
var tex_view0_width = 0;
var tex_view0_height = 0;

// Geometry style configuration
var line_width = 4.0;   // in pixels
var point_radius = 4.0; // in pixels

var palette_index = 0;
function colorPalette(color)
{
    var palettes = [
        // Spectral
        [0x9E0142FF,0xD53E4FFF,0xF46D43FF,0xFDAE61FF,0xFEE08BFF,0xFFFFBFFF,0xE6F598FF,0xABDDA4FF,0x66C2A5FF,0x3288BDFF,0x5E4FA2FF],
        // BrownBlueGreen
        [0x003C30FF,0x01665EFF,0x35978FFF,0x80CDC1FF,0xC7EAE5FF,0xF5F5F5FF,0xF6E8C3FF,0xDFC27DFF,0xBF812DFF,0x8C510AFF,0x543005FF],
        // Blue
        [0x08306BFF,0x08519CFF,0x2171B5FF,0x4292C6FF,0x6BAED6FF,0x9ECAE1FF,0xC6DBEFFF,0xDEEBF7FF,0xF7FBFFFF],
        // GreenBlue
        [0x084081FF,0x0868ACFF,0x2B8CBEFF,0x4EB3D3FF,0x7BCCC4FF,0xA8DDB5FF,0xCCEBC5FF,0xE0F3DBFF,0xF7FCF0FF],
        // Set 1
        [0xE41A1CFF,0x377EB8FF,0x4DAF4AFF,0x984EA3FF,0xFF7F00FF,0xFFFF33FF,0xA65628FF,0xF781BFFF]
    ];
    return palettes[palette_index][color % (palettes[palette_index].length)];
}

function alphaPalette(alpha)
{
    if (alpha == 0) return 255;
    if (alpha == 1) return 128;
}

function generateTriangles(commands)
{
    tex_view0_active = false;

    var coords = [];
    var colors = [];
    var count = 0;

    var little_endian = true;
    var view = new DataView(commands);
    var offset = 0;

    while (offset < view.byteLength)
    {
        var mode = view.getUint8(offset, little_endian); offset += 1;
        var style = view.getUint8(offset, little_endian); offset += 1;

        var style_color_index = style & 0x7F;
        var style_alpha_index = (style >> 7) & 0x01;
        var color = colorPalette(style_color_index);
        var color_r = (color >> 24) & 0xFF;
        var color_g = (color >> 16) & 0xFF;
        var color_b = (color >>  8) & 0xFF;
        var color_a = alphaPalette(style_alpha_index) & 0xFF;

        if (mode == 1) // point2
        {
            var x = view.getFloat32(offset, little_endian); offset += 4;
            var y = view.getFloat32(offset, little_endian); offset += 4;

            var rx = point_radius/(cvs.width/2.0);
            var ry = point_radius/(cvs.height/2.0);
            var n = 32;
            var wh = cvs.width/2.0;
            var hh = cvs.height/2.0;
            for (var i = 0; i < n; i++)
            {
                var t1 = 2.0*3.1415926*i/n;
                var t2 = 2.0*3.1415926*(i+1)/n;
                var x1 = x;
                var y1 = y;
                var x2 = x1 + rx*Math.cos(t1);
                var y2 = y1 + ry*Math.sin(t1);
                var x3 = x1 + rx*Math.cos(t2);
                var y3 = y1 + ry*Math.sin(t2);
                coords.push(x1,y1, x2,y2, x3,y3);
                colors.push(color_r,color_g,color_b,color_a,
                            color_r,color_g,color_b,color_a,
                            color_r,color_g,color_b,color_a);
                count += 3;
            }
        }
        else if (mode == 2) // point3
        {
            var x_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var y_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var z_ndc = view.getFloat32(offset, little_endian); offset += 4;
        }
        else if (mode == 3) // line2
        {
            var x1 = view.getFloat32(offset, little_endian); offset += 4;
            var y1 = view.getFloat32(offset, little_endian); offset += 4;
            var x2 = view.getFloat32(offset, little_endian); offset += 4;
            var y2 = view.getFloat32(offset, little_endian); offset += 4;

            var ln = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
            var nx = -(y2-y1) / ln;
            var ny = (x2-x1) / ln;

            var rx = (line_width/2.0)/(cvs.width/2.0);
            var ry = (line_width/2.0)/(cvs.height/2.0);
            var x11 = x1 - nx*rx;
            var y11 = y1 - ny*ry;
            var x21 = x2 - nx*rx;
            var y21 = y2 - ny*ry;
            var x12 = x1 + nx*rx;
            var y12 = y1 + ny*ry;
            var x22 = x2 + nx*rx;
            var y22 = y2 + ny*ry;

            coords.push(x11,y11, x21,y21, x22,y22, x22,y22, x12,y12, x11,y11);
            colors.push(color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a);
            count += 6;
        }
        else if (mode == 4) // line3
        {
            var x1_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var y1_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var z1_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var x2_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var y2_ndc = view.getFloat32(offset, little_endian); offset += 4;
            var z2_ndc = view.getFloat32(offset, little_endian); offset += 4;
        }
        else if (mode == 5) // fillRect
        {
            var x = view.getFloat32(offset, little_endian); offset += 4;
            var y = view.getFloat32(offset, little_endian); offset += 4;
            var w = view.getFloat32(offset, little_endian); offset += 4;
            var h = view.getFloat32(offset, little_endian); offset += 4;
            coords.push(x,y, x+w,y, x+w,y+h, x+w,y+h, x,y+h, x,y);
            colors.push(color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a,
                        color_r,color_g,color_b,color_a);
            count += 6;
        }
        else if (mode == 6) // circle
        {
            var x = view.getFloat32(offset, little_endian); offset += 4;
            var y = view.getFloat32(offset, little_endian); offset += 4;
            var r = view.getFloat32(offset, little_endian); offset += 4;

            var n = 32;
            for (var i = 0; i < n; i++)
            {
                var t1 = 2.0*3.1415926*i/n;
                var t2 = 2.0*3.1415926*(i+1)/n;
                var x1 = x;
                var y1 = y;
                var x2 = x1 + r*Math.cos(t1);
                var y2 = y1 + r*Math.sin(t1);
                var x3 = x1 + r*Math.cos(t2);
                var y3 = y1 + r*Math.sin(t2);
                coords.push(x1,y1, x2,y2, x3,y3);
                colors.push(color_r,color_g,color_b,color_a,
                            color_r,color_g,color_b,color_a,
                            color_r,color_g,color_b,color_a);
                count += 3;
            }
        }
        else if (mode == 7) // image_rgb8
        {
            var width = view.getUint32(offset, little_endian); offset += 4;
            var height = view.getUint32(offset, little_endian); offset += 4;
            var size = width*height*3;

            var data = new Uint8Array(commands, offset, size);
            offset += size;

            if (tex_view0_width != width || tex_view0_height != height)
            // if (1) // @ texture upload optimization
            {
                tex_view0_width = width;
                tex_view0_height = height;
                gl.bindTexture(gl.TEXTURE_2D, tex_view0);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_BYTE, data);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            else
            {
                gl.bindTexture(gl.TEXTURE_2D, tex_view0);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGB, gl.UNSIGNED_BYTE, data);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            tex_view0_active = true;
            data = null;
        }
        else if (mode == 255) // aspect
        {
            var w = view.getFloat32(offset, little_endian); offset += 4;
            var h = view.getFloat32(offset, little_endian); offset += 4;
            var new_w = cvs.clientHeight * w / h;

            var element = document.getElementById("canvas");
            element.style.width = new_w + "px";
        }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, vbo_user_coord);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coords), gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, vbo_user_color);
    gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(colors), gl.STATIC_DRAW);

    coords = null;
    colors = null;
    view = null;

    return count;
}

function createShader(gl, type, source)
{
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success)
        return shader;
    console.log(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
}

function createProgram(gl, vs, fs)
{
    var program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success)
        return program;
    console.log(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
}

function init()
{
    // Compile the ubershader
    var shader_vs_src = document.getElementById("shader_vs").text;
    var shader_fs_src = document.getElementById("shader_fs").text;
    var shader_vs = createShader(gl, gl.VERTEX_SHADER, shader_vs_src);
    var shader_fs = createShader(gl, gl.FRAGMENT_SHADER, shader_fs_src);
    program = createProgram(gl, shader_vs, shader_fs);

    // Get attribute locations
    loc_coord = gl.getAttribLocation(program, "coord");
    loc_color = gl.getAttribLocation(program, "color");
    loc_texel = gl.getAttribLocation(program, "texel");
    loc_chan0 = gl.getUniformLocation(program, "chan0");

    // These vertex buffers are updated in generateTriangles
    vbo_user_coord = gl.createBuffer();
    vbo_user_color = gl.createBuffer();
    vbo_user_texel = gl.createBuffer();

    // These vertex buffers are used to draw background textures
    vbo_quad_coord = gl.createBuffer();
    vbo_quad_color = gl.createBuffer();
    vbo_quad_texel = gl.createBuffer();
    {
        var coords = [ -1,-1, +1,-1, +1,+1, +1,+1, -1,+1, -1,-1 ];
        var texels = [ 0,0, 1,0, 1,1, 1,1, 0,1, 0,0 ];
        var colors = [ 255,255,255,255, 255,255,255,255, 255,255,255,255, 255,255,255,255, 255,255,255,255, 255,255,255,255 ];
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_quad_coord); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coords), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_quad_color); gl.bufferData(gl.ARRAY_BUFFER, new   Uint8Array(colors), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_quad_texel); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texels), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }

    // This texture is for drawing non-textured geometry
    tex_white = gl.createTexture();
    {
        var data = new Uint8Array([255,255,255,255]);
        gl.bindTexture(gl.TEXTURE_2D, tex_white);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    // These textures can be assigned data by the user (from generateTriangles)
    tex_view0 = gl.createTexture();
    tex_view0_active = false;
}

function draw()
{
    // Update parameters from GUI
    line_width = parseFloat(document.getElementById("line_width").value);
    point_radius = parseFloat(document.getElementById("point_radius").value);

    // Resize framebuffer resolution to match size of displayed window
    if (cvs.width  != cvs.clientWidth || cvs.height != cvs.clientHeight)
    {
        cvs.width  = cvs.clientWidth;
        cvs.height = cvs.clientHeight;
    }

    var num_elements = 0;
    if (cmd_data != null)
        num_elements = generateTriangles(cmd_data);

    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(program);

    // Draw background texture (if any)
    if (tex_view0_active)
    {
        gl.activeTexture(gl.TEXTURE0 + 0);
        gl.bindTexture(gl.TEXTURE_2D, tex_view0);
        gl.enableVertexAttribArray(loc_coord);
        gl.enableVertexAttribArray(loc_color);
        gl.enableVertexAttribArray(loc_texel);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_quad_coord);
        gl.vertexAttribPointer(loc_coord, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_quad_color);
        gl.vertexAttribPointer(loc_color, 4, gl.UNSIGNED_BYTE, true, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_quad_texel);
        gl.vertexAttribPointer(loc_texel, 2, gl.FLOAT, false, 0, 0);
        gl.uniform1i(loc_chan0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    // Draw user geometry
    if (num_elements > 0)
    {
        gl.activeTexture(gl.TEXTURE0 + 0);
        gl.bindTexture(gl.TEXTURE_2D, tex_white);
        gl.enableVertexAttribArray(loc_coord);
        gl.enableVertexAttribArray(loc_color);
        gl.disableVertexAttribArray(loc_texel);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_user_coord);
        gl.vertexAttribPointer(loc_coord, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo_user_color);
        gl.vertexAttribPointer(loc_color, 4, gl.UNSIGNED_BYTE, true, 0, 0);
        gl.uniform1i(loc_chan0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, num_elements);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
}

var fuck = 0;

function connect()
{
    setInterval(function()
    {
        if (!ws)
        {
            // console.log("Retry!");
            ws = new WebSocket("ws://localhost:8000");
            ws.binaryType = 'arraybuffer';

            ws.onopen = function()
            {
                // console.log("Sending data");
                ws.send("Hello from browser!");
                has_connection = true;
            }

            ws.onclose = function()
            {
                // console.log("Socket closed");
                ws = null;
                has_connection = false;
            }

            ws.onmessage = function(e)
            {
                cmd_data = e.data;
            }
        }
    }, 250);
}

var animation_frame_t_first = null;
var animation_frame_t_prev = null;
function anim(t)
{
    var delta = 1.0/60.0;
    var elapsed = 0.0;
    if (t)
    {
        if (!animation_frame_t_first) animation_frame_t_first = t;
        if (!animation_frame_t_prev) animation_frame_t_prev = t;
        delta = (t - animation_frame_t_prev)/1000.0;
        elapsed = (t - animation_frame_t_first)/1000.0;
        animation_frame_t_prev = t;
    }

    var status = document.getElementById("status");
    if (has_connection)
    {
        status.innerHTML = "Connected";
        draw();
    }
    else
    {
        status.innerHTML = "No connection";
        draw();
    }

    var p_fps = document.getElementById("fps");
    p_fps.innerText = "FPS: " + (1.0/delta).toPrecision(4);

    requestAnimationFrame(anim);
}

function onKeyUp(e)
{
    if (event.keyCode == 13)
        ws.send("c");
}

function load()
{
    if (!("WebSocket" in window))
    {
        alert("Your browser does not support WebSockets! Sorry, good luck!");
        return;
    }

    cvs = document.getElementById("canvas");
    // gl = cvs.getContext("webgl");
    gl = cvs.getContext("webgl", {antialias: false});
    if (!gl)
    {
        console.log("Your browser does not support WebGL! Sorry, good luck!");
        return;
    }

    document.onkeyup = onKeyUp;

    connect();
    init();
    anim();
}

function sendContinue()
{
    ws.send("c");
}
</script>
<!-- SCRIPT END-->

<!-- HTML BEGIN -->
</head>
<body onload="load()">
    <div id="container">
        <p id="status"></p>
        <p id="fps"></p>
        <canvas id="canvas"></canvas>

        <!-- <label for="select_viewport">Viewport</label>
        <select onchange="onchange_select_viewport()" id="select_viewport" name="select_viewport">
          <option value="letterbox">Letterbox</option>
          <option value="stretch">Stretch to fit</option>
        </select> -->

        <!-- <label for="color_palette">Colors</label>
        <select id="color_palette" name="color_palette">
          <option value="0">Spectral</option>
          <option value="1">BrownBlueGreen</option>
          <option value="2">Blue</option>
          <option value="3">GreenBlue</option>
          <option value="4">Set 1</option>
        </select> -->

        <!-- <label>Line size</label> -->
        <input id="line_width" min="1.0" max="32.0" value="4.0" type="range"/>
        <!-- <label>Point size</label> -->
        <input id="point_radius" min="1.0" max="32.0" value="4.0" type="range"/>

        <a class="button" style="float:right;" href="javascript:sendContinue()">Continue</a>
    </div>
</body>
</html>
<!-- HTML END -->
